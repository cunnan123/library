内存生命周期
    内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存
    内存使用：即读写内存，也就是使用变量、函数等
    内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存
垃圾回收
    引用 
        垃圾回收算法主要依赖于引用的概念。
    引用计数垃圾收集
        这是最初级的垃圾回收算法。
        引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。
        存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露。
            function f(){
            var o = {};
            var o2 = {};
            o.a = o2; // o 引用 o2
            o2.a = o; // o2 引用 o  这里
            return "azerty";
            }
            f()
    标记清除算法
        标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。
        从这个概念可以看出，无法触及的对象包含了没有引用的对象这个概念（没有任何引用的对象也是无法触及的对象）。但反之未必成立。
        工作流程：
            1.垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。
            2.从根部出发将能触及到的对象的标记清除。
            3.那些还存在标记的变量被视为准备删除的变量。
            4.最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间

            再看之前循环引用的例子：
            函数调用返回之后，两个循环引用的对象在垃圾收集时从全局对象出发无法再获取他们的引用。因此，他们将会被垃圾回收器回收。
内存泄漏
    本质上讲,内存泄漏就是由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。
    内存泄漏的识别方法
        经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。这就要求实时查看内存的占用情况。
        在 Chrome 浏览器中，我们可以这样查看内存占用情况
            打开开发者工具，选择 Performance 面板
            在顶部勾选 Memory
            点击左上角的 record 按钮
            在页面上进行各种操作，模拟用户的使用情况
            一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况
 
            我们有两种方式来判定当前是否有内存泄漏：
                多次快照后，比较每次快照中内存的占用情况，如果呈上升趋势，那么可以认为存在内存泄漏
                某次快照后，看当前内存占用的趋势图，如果走势不平稳，呈上升趋势，那么可以认为存在内存泄漏
    在服务器环境中使用 Node 提供的 process.memoryUsage 方法查看内存情况
        console.log(process.memoryUsage());
        // {
        //     rss: 27709440,
        //     heapTotal: 5685248,
        //     heapUsed: 3449392,
        //     external: 8772
        // }
        process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。
        该对象包含四个字段，单位是字节，含义如下:
            rss（resident set size）：所有内存占用，包括指令区和堆栈。
            heapTotal："堆"占用的内存，包括用到的和没用到的。
            heapUsed：用到的堆的部分。
            external：V8 引擎内部的 C++ 对象占用的内存。
        判断内存泄漏，以heapUsed字段为准
常见的内存泄露案例
    1. 意外的全局变量
    2. 被遗忘的定时器和回调函数
    3. 闭包
    4. DOM 引用
如何避免内存泄漏
    记住一个原则：不用的东西，及时归还。
        减少不必要的全局变量，使用严格模式避免意外创建全局变量。
        在你使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）。
        组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。
